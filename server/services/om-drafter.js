/**
 * OM (Offering Memorandum) Drafter Service
 *
 * AI-powered generation of Offering Memorandums from extracted claims.
 * All generated content links back to source claims for provenance.
 *
 * Features:
 * - Section-by-section OM generation
 * - Claim-based content with provenance linking
 * - Conservative drafting with hedged language
 * - Automatic conflict flagging
 * - Version management with broker/seller approval workflow
 *
 * Phase 2: Deal Intake Platform - OM Generation + Seller Flow
 */

import { PrismaClient } from '@prisma/client';
import crypto from 'crypto';

const prisma = new PrismaClient();

// OpenAI configuration
const OPENAI_API_KEY = process.env.BFF_OPENAI_API_KEY;
const OPENAI_MODEL = process.env.BFF_OPENAI_MODEL || 'gpt-4o-mini';
const OPENAI_BASE_URL = process.env.BFF_OPENAI_BASE_URL || 'https://api.openai.com/v1';

// Debug logging helper
const DEBUG = process.env.DEBUG_OM_DRAFTER === 'true' || process.env.NODE_ENV !== 'production';

function log(level, message, data = {}) {
  const timestamp = new Date().toISOString();
  const prefix = `[OMDrafter][${level.toUpperCase()}]`;

  if (level === 'error') {
    console.error(`${timestamp} ${prefix} ${message}`, data);
  } else if (level === 'warn') {
    console.warn(`${timestamp} ${prefix} ${message}`, data);
  } else if (DEBUG || level === 'info') {
    console.log(`${timestamp} ${prefix} ${message}`, data);
  }
}

// OM Section Schema - defines all sections and their requirements
const OM_SECTIONS = {
  cover: {
    id: 'cover',
    title: 'Cover Page',
    required: true,
    fields: ['propertyName', 'propertyAddress', 'assetType', 'brokerName', 'brokerFirm'],
    template: `Generate a professional cover page summary for this commercial real estate offering memorandum.`
  },
  executive_summary: {
    id: 'executive_summary',
    title: 'Executive Summary',
    required: true,
    fields: ['askingPrice', 'capRate', 'pricePerUnit', 'pricePerSF', 'investmentHighlights'],
    template: `Generate an executive summary highlighting the key investment metrics and deal highlights.
Use hedged language like "approximately", "as reported", "subject to verification".
Do NOT state unverified figures as fact.`
  },
  property_overview: {
    id: 'property_overview',
    title: 'Property Overview',
    required: true,
    fields: ['propertyName', 'propertyAddress', 'yearBuilt', 'unitCount', 'totalSF', 'assetType'],
    template: `Generate a property overview describing the physical attributes of the asset.
Include any available details about amenities, condition, and recent capital improvements.`
  },
  financial_summary: {
    id: 'financial_summary',
    title: 'Financial Summary',
    required: true,
    fields: ['currentNOI', 'proFormaNOI', 'operatingExpenses', 'capRate', 'grossPotentialRent', 'effectiveGrossIncome'],
    template: `Generate a financial summary covering NOI, expenses, and key financial metrics.
Label all figures with their source. Use conservative estimates when multiple sources conflict.`
  },
  rent_roll_summary: {
    id: 'rent_roll_summary',
    title: 'Rent Roll Summary',
    required: true,
    fields: ['occupancy', 'averageRent', 'unitCount', 'occupiedUnits', 'vacantUnits', 'mtmUnits'],
    template: `Generate a rent roll summary covering occupancy, average rents, and lease structure.`
  },
  market_overview: {
    id: 'market_overview',
    title: 'Market Overview',
    required: false,
    fields: [],
    template: `Generate a market overview section. Note that specific market data should be verified independently.`
  },
  investment_thesis: {
    id: 'investment_thesis',
    title: 'Investment Thesis',
    required: false,
    fields: ['investmentHighlights'],
    template: `Generate an investment thesis highlighting value-add opportunities and growth potential.
Use forward-looking language appropriately (e.g., "potential", "opportunity to").`
  },
  transaction_terms: {
    id: 'transaction_terms',
    title: 'Transaction Terms',
    required: true,
    fields: ['askingPrice', 'brokerName', 'brokerEmail', 'brokerPhone'],
    template: `Generate transaction terms including guidance price and contact information.`
  },
  disclaimers: {
    id: 'disclaimers',
    title: 'Disclaimers',
    required: true,
    fields: [],
    autogenerated: true,
    content: `CONFIDENTIALITY & DISCLAIMER

This Offering Memorandum has been prepared solely for informational purposes and does not constitute an offer to sell or a solicitation of an offer to buy any interest in the property.

All information contained herein is based on data supplied by the seller and third-party sources deemed reliable. Neither the broker nor the platform makes any representations or warranties, express or implied, regarding the accuracy or completeness of the information provided.

Prospective investors must independently verify all material facts prior to submitting an offer. The financial projections contained herein are estimates only and actual results may vary materially.

This document is confidential and is intended solely for the use of the recipient. Distribution or reproduction of this document without prior written consent is strictly prohibited.`
  }
};

// Valid OM statuses
const OM_STATUSES = {
  DRAFT: 'DRAFT',
  BROKER_APPROVED: 'BROKER_APPROVED',
  SELLER_APPROVED: 'SELLER_APPROVED',
  MARKETING: 'MARKETING'
};

class OMDrafterService {
  /**
   * Generate a new OM draft from deal claims
   *
   * @param {string} dealDraftId - Deal draft ID
   * @param {Object} options
   * @param {string} options.createdBy - User ID creating the draft
   * @param {string} options.createdByName - User display name
   * @param {boolean} options.regenerate - Force regeneration even if draft exists
   * @returns {Promise<Object>} Created OMVersion
   */
  async generateOMDraft(dealDraftId, options = {}) {
    const { createdBy, createdByName, regenerate = false } = options;

    log('info', 'Starting OM draft generation', { dealDraftId, regenerate });

    // Get deal draft with claims
    const dealDraft = await prisma.dealDraft.findUnique({
      where: { id: dealDraftId },
      include: {
        claims: {
          where: { status: { in: ['UNVERIFIED', 'BROKER_CONFIRMED', 'SELLER_CONFIRMED'] } },
          orderBy: { confidence: 'desc' }
        },
        documents: true,
        brokers: { where: { isPrimaryContact: true } },
        seller: true,
        omVersions: {
          orderBy: { versionNumber: 'desc' },
          take: 1
        }
      }
    });

    if (!dealDraft) {
      log('error', 'Deal draft not found', { dealDraftId });
      throw new Error('Deal draft not found');
    }

    log('debug', 'Loaded deal draft', {
      dealDraftId,
      claimCount: dealDraft.claims.length,
      documentCount: dealDraft.documents.length,
      hasExistingOM: dealDraft.omVersions.length > 0
    });

    // Check for existing draft
    if (dealDraft.omVersions.length > 0 && !regenerate) {
      const existingOM = dealDraft.omVersions[0];
      if (existingOM.status === OM_STATUSES.DRAFT) {
        log('info', 'Returning existing draft OM', { omVersionId: existingOM.id });
        return this.formatOMVersion(existingOM);
      }
    }

    // Build claim map for quick lookup
    const claimMap = this.buildClaimMap(dealDraft.claims);
    log('debug', 'Built claim map', { fieldCount: Object.keys(claimMap).length });

    // Generate sections
    const sections = {};
    const usedClaimIds = new Set();
    const missingRequiredFields = [];

    for (const [sectionId, sectionDef] of Object.entries(OM_SECTIONS)) {
      log('debug', 'Generating section', { sectionId, required: sectionDef.required });

      try {
        const sectionResult = await this.generateSection(
          sectionId,
          sectionDef,
          claimMap,
          dealDraft
        );

        sections[sectionId] = sectionResult;

        // Track used claims
        if (sectionResult.claimRefs) {
          sectionResult.claimRefs.forEach(id => usedClaimIds.add(id));
        }

        // Track missing required fields
        if (sectionDef.required && sectionResult.missingFields?.length > 0) {
          missingRequiredFields.push(...sectionResult.missingFields.map(f => ({
            section: sectionId,
            field: f
          })));
        }

        log('debug', 'Section generated', {
          sectionId,
          claimCount: sectionResult.claimRefs?.length || 0,
          missingFields: sectionResult.missingFields?.length || 0
        });
      } catch (error) {
        log('error', 'Section generation failed', { sectionId, error: error.message });
        sections[sectionId] = {
          title: sectionDef.title,
          status: 'ERROR',
          error: error.message
        };
      }
    }

    // Determine next version number
    const nextVersion = (dealDraft.omVersions[0]?.versionNumber || 0) + 1;

    // Create OM content structure
    const omContent = {
      generatedAt: new Date().toISOString(),
      dealDraftId,
      version: nextVersion,
      sections,
      metadata: {
        totalClaims: dealDraft.claims.length,
        usedClaims: usedClaimIds.size,
        missingRequiredFields,
        documentSources: dealDraft.documents.map(d => ({
          id: d.id,
          name: d.originalFilename,
          type: d.classifiedType
        }))
      }
    };

    log('info', 'OM content structure created', {
      version: nextVersion,
      sectionCount: Object.keys(sections).length,
      usedClaimCount: usedClaimIds.size,
      missingFieldCount: missingRequiredFields.length
    });

    // Create OMVersion record
    const omVersion = await prisma.$transaction(async (tx) => {
      const version = await tx.oMVersion.create({
        data: {
          dealDraftId,
          versionNumber: nextVersion,
          status: OM_STATUSES.DRAFT,
          content: JSON.stringify(omContent),
          claimRefs: JSON.stringify([...usedClaimIds]),
          createdBy: createdBy || 'system',
          createdByName: createdByName || 'System'
        }
      });

      // Update deal draft status if needed
      if (dealDraft.status === 'DRAFT_INGESTED') {
        await tx.dealDraft.update({
          where: { id: dealDraftId },
          data: { status: 'OM_DRAFTED' }
        });

        log('info', 'Deal draft status advanced to OM_DRAFTED', { dealDraftId });
      }

      // Log event
      await tx.dealIntakeEventLog.create({
        data: {
          dealDraftId,
          organizationId: dealDraft.organizationId,
          eventType: 'OM_DRAFT_GENERATED',
          eventData: JSON.stringify({
            omVersionId: version.id,
            versionNumber: nextVersion,
            sectionCount: Object.keys(sections).length,
            claimCount: usedClaimIds.size,
            missingRequiredFields
          }),
          actorId: createdBy || 'system',
          actorName: createdByName || 'System',
          actorRole: 'SYSTEM'
        }
      });

      return version;
    });

    log('info', 'OM draft created successfully', {
      omVersionId: omVersion.id,
      versionNumber: omVersion.versionNumber
    });

    return this.formatOMVersion(omVersion);
  }

  /**
   * Build a map of field -> best claim for that field
   */
  buildClaimMap(claims) {
    const claimMap = {};

    for (const claim of claims) {
      const field = claim.field;

      // If we don't have this field yet, or this claim has higher priority
      if (!claimMap[field] || this.claimPriority(claim) > this.claimPriority(claimMap[field].claim)) {
        claimMap[field] = {
          claim,
          value: JSON.parse(claim.value),
          displayValue: claim.displayValue
        };
      }
    }

    return claimMap;
  }

  /**
   * Calculate claim priority (higher = better)
   */
  claimPriority(claim) {
    let priority = claim.confidence * 100;

    // Verified claims get a big boost
    if (claim.status === 'SELLER_CONFIRMED') priority += 1000;
    if (claim.status === 'BROKER_CONFIRMED') priority += 500;

    // Claims from primary documents get a boost
    // T12 and Rent Roll are most reliable for financial data
    const docType = claim.documentType || '';
    if (docType === 'T12') priority += 50;
    if (docType === 'RENT_ROLL') priority += 50;
    if (docType === 'OFFERING_MEMO') priority += 30;

    return priority;
  }

  /**
   * Generate a single OM section
   */
  async generateSection(sectionId, sectionDef, claimMap, dealDraft) {
    // Handle auto-generated sections (like disclaimers)
    if (sectionDef.autogenerated) {
      return {
        id: sectionId,
        title: sectionDef.title,
        status: 'COMPLETE',
        content: sectionDef.content,
        claimRefs: [],
        missingFields: [],
        generated: false
      };
    }

    // Gather claims for this section
    const sectionClaims = {};
    const missingFields = [];
    const claimRefs = [];

    for (const field of sectionDef.fields) {
      if (claimMap[field]) {
        sectionClaims[field] = {
          value: claimMap[field].value,
          displayValue: claimMap[field].displayValue,
          confidence: claimMap[field].claim.confidence,
          source: {
            documentName: claimMap[field].claim.documentName,
            pageNumber: claimMap[field].claim.pageNumber,
            textSnippet: claimMap[field].claim.textSnippet
          },
          status: claimMap[field].claim.status
        };
        claimRefs.push(claimMap[field].claim.id);
      } else {
        missingFields.push(field);
      }
    }

    // Add property info from deal draft if available
    if (dealDraft.propertyName && !sectionClaims.propertyName) {
      sectionClaims.propertyName = { value: dealDraft.propertyName, displayValue: dealDraft.propertyName };
    }
    if (dealDraft.propertyAddress && !sectionClaims.propertyAddress) {
      sectionClaims.propertyAddress = { value: dealDraft.propertyAddress, displayValue: dealDraft.propertyAddress };
    }
    if (dealDraft.assetType && !sectionClaims.assetType) {
      sectionClaims.assetType = { value: dealDraft.assetType, displayValue: dealDraft.assetType };
    }

    // Add broker info
    const primaryBroker = dealDraft.brokers?.[0];
    if (primaryBroker) {
      if (!sectionClaims.brokerName) {
        sectionClaims.brokerName = { value: primaryBroker.name, displayValue: primaryBroker.name };
      }
      if (!sectionClaims.brokerFirm) {
        sectionClaims.brokerFirm = { value: primaryBroker.firmName, displayValue: primaryBroker.firmName };
      }
      if (!sectionClaims.brokerEmail) {
        sectionClaims.brokerEmail = { value: primaryBroker.email, displayValue: primaryBroker.email };
      }
    }

    // If we have no claims for this section, return a placeholder
    if (Object.keys(sectionClaims).length === 0) {
      return {
        id: sectionId,
        title: sectionDef.title,
        status: 'MISSING_DATA',
        content: `[This section requires data that has not yet been extracted or verified. Missing fields: ${missingFields.join(', ')}]`,
        claimRefs: [],
        missingFields,
        generated: false
      };
    }

    // Generate content using LLM if API key is available
    let content;
    let generated = false;

    if (OPENAI_API_KEY) {
      try {
        content = await this.generateSectionContent(sectionDef, sectionClaims);
        generated = true;
      } catch (error) {
        log('warn', 'LLM generation failed, using template', { sectionId, error: error.message });
        content = this.generateTemplateContent(sectionDef, sectionClaims);
      }
    } else {
      log('debug', 'No API key, using template generation', { sectionId });
      content = this.generateTemplateContent(sectionDef, sectionClaims);
    }

    return {
      id: sectionId,
      title: sectionDef.title,
      status: missingFields.length > 0 ? 'PARTIAL' : 'COMPLETE',
      content,
      claims: sectionClaims,
      claimRefs,
      missingFields,
      generated
    };
  }

  /**
   * Generate section content using LLM
   */
  async generateSectionContent(sectionDef, sectionClaims) {
    log('debug', 'Calling LLM for section generation', { sectionId: sectionDef.id });

    const claimsText = Object.entries(sectionClaims)
      .map(([field, data]) => `- ${field}: ${data.displayValue || data.value} (confidence: ${data.confidence || 'N/A'}, source: ${data.source?.documentName || 'deal data'})`)
      .join('\n');

    const prompt = `${sectionDef.template}

Available data:
${claimsText}

Generate professional, concise content for this "${sectionDef.title}" section of a commercial real estate offering memorandum.

Rules:
1. Use hedged language for unverified data ("approximately", "as reported", "subject to verification")
2. Label figures with their sources where appropriate
3. Do NOT make up data that isn't provided
4. Keep formatting clean and professional
5. If key data is missing, note what additional information would be helpful

Return ONLY the section content, no headers or JSON.`;

    try {
      const response = await fetch(`${OPENAI_BASE_URL}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${OPENAI_API_KEY}`
        },
        body: JSON.stringify({
          model: OPENAI_MODEL,
          messages: [
            {
              role: 'system',
              content: 'You are a professional commercial real estate analyst drafting an Offering Memorandum. Be concise, professional, and conservative with claims. Never overstate or speculate.'
            },
            { role: 'user', content: prompt }
          ],
          temperature: 0.3,
          max_tokens: 1500
        })
      });

      if (!response.ok) {
        const error = await response.text();
        log('error', 'OpenAI API error', { error });
        throw new Error(`OpenAI API error: ${response.status}`);
      }

      const data = await response.json();
      const content = data.choices?.[0]?.message?.content?.trim();

      if (!content) {
        throw new Error('Empty response from LLM');
      }

      log('debug', 'LLM generation successful', { sectionId: sectionDef.id, contentLength: content.length });
      return content;
    } catch (error) {
      log('error', 'LLM call failed', { sectionId: sectionDef.id, error: error.message });
      throw error;
    }
  }

  /**
   * Generate section content using simple template (fallback)
   */
  generateTemplateContent(sectionDef, sectionClaims) {
    const lines = [];

    for (const [field, data] of Object.entries(sectionClaims)) {
      const label = this.formatFieldLabel(field);
      const value = data.displayValue || data.value;
      lines.push(`**${label}:** ${value}`);
    }

    return lines.join('\n\n');
  }

  /**
   * Format field name as readable label
   */
  formatFieldLabel(field) {
    return field
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase())
      .trim();
  }

  /**
   * Get an OM version by ID
   */
  async getOMVersion(omVersionId) {
    log('debug', 'Fetching OM version', { omVersionId });

    const version = await prisma.oMVersion.findUnique({
      where: { id: omVersionId }
    });

    if (!version) {
      throw new Error('OM version not found');
    }

    return this.formatOMVersion(version);
  }

  /**
   * Get the latest OM version for a deal
   */
  async getLatestOMVersion(dealDraftId) {
    log('debug', 'Fetching latest OM version', { dealDraftId });

    const version = await prisma.oMVersion.findFirst({
      where: { dealDraftId },
      orderBy: { versionNumber: 'desc' }
    });

    if (!version) {
      return null;
    }

    return this.formatOMVersion(version);
  }

  /**
   * List all OM versions for a deal
   */
  async listOMVersions(dealDraftId) {
    log('debug', 'Listing OM versions', { dealDraftId });

    const versions = await prisma.oMVersion.findMany({
      where: { dealDraftId },
      orderBy: { versionNumber: 'desc' }
    });

    return versions.map(v => this.formatOMVersion(v, false));
  }

  /**
   * Update OM section content (broker edit)
   */
  async updateSection(omVersionId, sectionId, updates, actor) {
    log('info', 'Updating OM section', { omVersionId, sectionId, actor: actor.id });

    const version = await prisma.oMVersion.findUnique({
      where: { id: omVersionId }
    });

    if (!version) {
      throw new Error('OM version not found');
    }

    if (version.status !== OM_STATUSES.DRAFT) {
      throw new Error(`Cannot edit OM in ${version.status} status. Create a new version instead.`);
    }

    const content = JSON.parse(version.content);

    if (!content.sections[sectionId]) {
      throw new Error(`Section ${sectionId} not found`);
    }

    // Apply updates
    const oldContent = content.sections[sectionId].content;
    content.sections[sectionId] = {
      ...content.sections[sectionId],
      ...updates,
      lastEditedBy: actor.id,
      lastEditedByName: actor.name,
      lastEditedAt: new Date().toISOString()
    };

    // Track change
    const changeLog = JSON.parse(version.changeLog || '[]');
    changeLog.push({
      timestamp: new Date().toISOString(),
      sectionId,
      actorId: actor.id,
      actorName: actor.name,
      type: 'SECTION_EDIT',
      oldContentLength: oldContent?.length || 0,
      newContentLength: updates.content?.length || 0
    });

    const updated = await prisma.oMVersion.update({
      where: { id: omVersionId },
      data: {
        content: JSON.stringify(content),
        changeLog: JSON.stringify(changeLog)
      }
    });

    log('info', 'Section updated', { omVersionId, sectionId });

    return this.formatOMVersion(updated);
  }

  /**
   * Broker approves the OM draft
   */
  async brokerApprove(omVersionId, actor) {
    log('info', 'Broker approving OM', { omVersionId, actor: actor.id });

    const version = await prisma.oMVersion.findUnique({
      where: { id: omVersionId },
      include: {
        dealDraft: true
      }
    });

    if (!version) {
      throw new Error('OM version not found');
    }

    if (version.status !== OM_STATUSES.DRAFT) {
      throw new Error(`Cannot approve OM in ${version.status} status`);
    }

    const updated = await prisma.$transaction(async (tx) => {
      const om = await tx.oMVersion.update({
        where: { id: omVersionId },
        data: {
          status: OM_STATUSES.BROKER_APPROVED,
          brokerApprovedBy: actor.id,
          brokerApprovedAt: new Date()
        }
      });

      // Update deal draft status
      await tx.dealDraft.update({
        where: { id: version.dealDraftId },
        data: { status: 'OM_BROKER_APPROVED' }
      });

      // Log event
      await tx.dealIntakeEventLog.create({
        data: {
          dealDraftId: version.dealDraftId,
          organizationId: version.dealDraft.organizationId,
          eventType: 'OM_BROKER_APPROVED',
          eventData: JSON.stringify({
            omVersionId: om.id,
            versionNumber: om.versionNumber
          }),
          actorId: actor.id,
          actorName: actor.name,
          actorRole: 'BROKER'
        }
      });

      return om;
    });

    log('info', 'OM broker approved', { omVersionId });

    return this.formatOMVersion(updated);
  }

  /**
   * Seller approves the OM (unlocks distribution)
   */
  async sellerApprove(omVersionId, actor) {
    log('info', 'Seller approving OM', { omVersionId, actor: actor.id });

    const version = await prisma.oMVersion.findUnique({
      where: { id: omVersionId },
      include: {
        dealDraft: true
      }
    });

    if (!version) {
      throw new Error('OM version not found');
    }

    if (version.status !== OM_STATUSES.BROKER_APPROVED) {
      throw new Error(`Seller can only approve OM in BROKER_APPROVED status. Current: ${version.status}`);
    }

    const updated = await prisma.$transaction(async (tx) => {
      const om = await tx.oMVersion.update({
        where: { id: omVersionId },
        data: {
          status: OM_STATUSES.SELLER_APPROVED,
          sellerApprovedBy: actor.id,
          sellerApprovedAt: new Date()
        }
      });

      // Update deal draft status - ready for marketing/distribution
      await tx.dealDraft.update({
        where: { id: version.dealDraftId },
        data: { status: 'OM_APPROVED_FOR_MARKETING' }
      });

      // Log event
      await tx.dealIntakeEventLog.create({
        data: {
          dealDraftId: version.dealDraftId,
          organizationId: version.dealDraft.organizationId,
          eventType: 'OM_SELLER_APPROVED',
          eventData: JSON.stringify({
            omVersionId: om.id,
            versionNumber: om.versionNumber
          }),
          actorId: actor.id,
          actorName: actor.name,
          actorRole: 'SELLER'
        }
      });

      return om;
    });

    log('info', 'OM seller approved - ready for distribution', { omVersionId });

    return this.formatOMVersion(updated);
  }

  /**
   * Request changes (sends back to draft)
   */
  async requestChanges(omVersionId, actor, feedback) {
    log('info', 'Requesting OM changes', { omVersionId, actor: actor.id });

    const version = await prisma.oMVersion.findUnique({
      where: { id: omVersionId },
      include: {
        dealDraft: true
      }
    });

    if (!version) {
      throw new Error('OM version not found');
    }

    // Track the change request in the changelog
    const changeLog = JSON.parse(version.changeLog || '[]');
    changeLog.push({
      timestamp: new Date().toISOString(),
      actorId: actor.id,
      actorName: actor.name,
      actorRole: actor.role || 'UNKNOWN',
      type: 'CHANGE_REQUEST',
      previousStatus: version.status,
      feedback
    });

    const updated = await prisma.$transaction(async (tx) => {
      const om = await tx.oMVersion.update({
        where: { id: omVersionId },
        data: {
          status: OM_STATUSES.DRAFT,
          changeLog: JSON.stringify(changeLog),
          // Clear approvals since we're going back to draft
          brokerApprovedBy: null,
          brokerApprovedAt: null,
          sellerApprovedBy: null,
          sellerApprovedAt: null
        }
      });

      // Update deal draft status back to OM_DRAFTED
      await tx.dealDraft.update({
        where: { id: version.dealDraftId },
        data: { status: 'OM_DRAFTED' }
      });

      // Log event
      await tx.dealIntakeEventLog.create({
        data: {
          dealDraftId: version.dealDraftId,
          organizationId: version.dealDraft.organizationId,
          eventType: 'OM_CHANGE_REQUESTED',
          eventData: JSON.stringify({
            omVersionId: om.id,
            versionNumber: om.versionNumber,
            requestedBy: actor.id,
            feedback
          }),
          actorId: actor.id,
          actorName: actor.name,
          actorRole: actor.role || 'UNKNOWN'
        }
      });

      return om;
    });

    log('info', 'OM sent back for changes', { omVersionId });

    return this.formatOMVersion(updated);
  }

  /**
   * Format OM version for API response
   */
  formatOMVersion(version, includeContent = true) {
    const formatted = {
      id: version.id,
      dealDraftId: version.dealDraftId,
      versionNumber: version.versionNumber,
      status: version.status,
      approval: {
        brokerApprovedBy: version.brokerApprovedBy,
        brokerApprovedAt: version.brokerApprovedAt,
        sellerApprovedBy: version.sellerApprovedBy,
        sellerApprovedAt: version.sellerApprovedAt
      },
      createdBy: version.createdBy,
      createdByName: version.createdByName,
      createdAt: version.createdAt
    };

    if (includeContent) {
      formatted.content = JSON.parse(version.content);
      formatted.claimRefs = version.claimRefs ? JSON.parse(version.claimRefs) : [];
      formatted.changeLog = version.changeLog ? JSON.parse(version.changeLog) : [];
    }

    return formatted;
  }
}

// Export singleton instance
const omDrafterService = new OMDrafterService();

export {
  omDrafterService,
  OMDrafterService,
  OM_SECTIONS,
  OM_STATUSES
};
